/*
 * generated by Xtext 2.13.0
 */
package it.imt.ui.labeling

import com.google.inject.Inject
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider

import it.imt.qFLan.QFLanVariables
import it.imt.qFLan.AbstractFeatures
import it.imt.qFLan.ConcreteFeatures
import it.imt.qFLan.RealtionsAmongFeatures
import it.imt.qFLan.CrossTreeConstraints
import it.imt.qFLan.FeaturePredicates
import it.imt.qFLan.QuantitativeConstraints
import it.imt.qFLan.Actions
import it.imt.qFLan.ActionConstraints
import it.imt.qFLan.Processes
import it.imt.qFLan.FatherAndSons
import it.imt.qFLan.XORFatherAndSons
import it.imt.qFLan.ORFatherAndSons
import it.imt.qFLan.SetOfPossiblyOptionalFeatures
import it.imt.qFLan.SetOfFeatures
import it.imt.qFLan.FeatureRequires
import it.imt.qFLan.FeatureExcludes
import it.imt.qFLan.Feature
import it.imt.qFLan.AbstractFeature
import it.imt.qFLan.ConcreteFeature
import it.imt.qFLan.FeaturePredicateValue
import it.imt.MyParserUtil
import it.imt.qFLan.Expression
import it.imt.qFLan.BoolExpr
import it.imt.qFLan.ActionRequires
import it.imt.qFLan.ProcessExpr
import it.imt.qFLan.Simulate
import it.imt.qFLan.Analysis
import it.imt.qFLan.QFLanVariable
import it.imt.qFLan.SetOfConcreteFeatures
import it.imt.qFLan.NonParametricQueries
import it.imt.qFLan.NonParametricQuery
import it.imt.qFLan.SetOfObs
import it.imt.qFLan.ParametricQuery
import it.imt.qFLan.AdditionWithPredicatesAndFeaturesWithOptionalDelta
import it.imt.qFLan.InitWithProcesses
import it.imt.qFLan.ProcessDiagram
import it.imt.qFLan.InitWithProcessDiagram
import it.imt.qFLan.ProcessTransition
import it.imt.qFLan.SideEffects
import it.imt.qFLan.States
import it.imt.qFLan.Transitions
import it.imt.qFLan.ZeroProcess
import it.imt.qFLan.ReferenceToProcessState

/**
 * Provides labels for EObjects.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#label-provider
 */
class QFLanLabelProvider extends DefaultEObjectLabelProvider {

	@Inject
	new(AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}

	// Labels and icons can be computed like this:
	
//	def text(Greeting ele) {
//		'A greeting to ' + ele.name
//	}
//
//	def image(Greeting ele) {
//		'Greeting.gif'
//	}

	/*def text(ZeroProcess zero){
		'nil'
	}*/

	/*def text(ProcessOfDiagram proc){
		proc.name + ' (' + write(proc.states.size,' state') + ', and ' + write(proc.transitions.size,' transition') +')'
	}*/
	def text(States states){
		write(states.states.size,' state')
	}
	def text(Transitions transitions){
		write(transitions.transitions.size,' transition')
	}
	

	def text(ProcessTransition trans){
		if(trans.sideEffects!==null && trans.sideEffects.effects!==null && trans.sideEffects.effects.size>0){
			trans.source.name + ' -(' + MyParserUtil.visitActionIncludingAskOrStoreModifierOrFeature(trans.action) + ',' + 
			text(trans.rate) + ',' + text(trans.sideEffects) + ')-> ' + computeTarget(trans)
		}
		else{
			trans.source.name + ' -(' + MyParserUtil.visitActionIncludingAskOrStoreModifierOrFeature(trans.action) + ',' + 
			text(trans.rate) + ')-> ' + computeTarget(trans)	
		}
	}
	
	def computeTarget(ProcessTransition transition){
		var target="nil"
		var tt=transition.target
		if(!(tt instanceof ZeroProcess)){
			var tt2 = tt as ReferenceToProcessState
			target = tt2.value.name
		}
		return target
	}
	
	def text(SideEffects effects) {
		var sb = new StringBuilder();
		sb.append("{");
		if(effects!==null){
			var listOfEffects = effects.effects;
			var size = listOfEffects.size;
			var i=0;
			if(listOfEffects!==null){
				for(eff : listOfEffects){
					var name = eff.refToQFLanVar.getVarqflan.name
					var expr = eff.value;
					sb.append('''«name»=«text(expr)»)''')
					if(i<size-1){
						sb.append(",");
					}
					i++;
				}
			}
		}
		sb.append("}");
		return sb.toString;
	}

	def text(NonParametricQueries blockWithList){
		var list = blockWithList.queries
		if(list===null){
			'0 queries'
		}
		else{
			var s=list.size
			if(s==1){
				s +' query'
			}
			else{
				s + " queries"
			}
		}
	}
	def text(NonParametricQuery npq){
		text(npq.mqObs) + ' when ' + text(npq.cond)
	}
	def text(SetOfObs blockWithList){
		var what=' observation'
		var list = blockWithList.obs
		if(list===null){
			write(0,what)
		}
		else{
			write(list.size,what)
		}
	}
	def text(ParametricQuery pq){
		text(pq.mqObs) + ' from ' + pq.from+ ' to '+ pq.to + ' (with increment '+pq.step+')'
	}
	def text(AdditionWithPredicatesAndFeaturesWithOptionalDelta obs){
		var ret=MyParserUtil.visitExpr(obs.obs)
		if(obs.delta!==null){
			ret=ret+' with delta '+ MyParserUtil.visitExpr(obs.delta)
		}
		return ret
	}
	

	def text(QFLanVariables blockWithList){
		var what=' variable'
		var list = blockWithList.variables
		if(list===null){
			write(0,what)
		}
		else{
			write(list.size,what)
		}
	}
	
	def text(AbstractFeatures blockWithList){
		var what=' abstract feature'
		var list = blockWithList.abstractFeatures
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	
	def text(ConcreteFeatures blockWithList){
		var what=' concrete feature'
		var list = blockWithList.concreteFeatures
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	
	def text(RealtionsAmongFeatures blockWithList){
		var what=' feature relation'
		var list = blockWithList.relations
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	
	def text(CrossTreeConstraints blockWithList){
		var what=' cross tree constraint'
		var list = blockWithList.crossTreeConstraints
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	
	def text(FeaturePredicates blockWithList){
		var what=' feature predicate'
		var list = blockWithList.featurePredicates
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	
	def text(QuantitativeConstraints blockWithList){
		var what=' quantitative constraint'
		var list = blockWithList.quantitativeConstraints
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	
	def text(Actions blockWithList){
		var what=' action'
		var list = blockWithList.actions
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	
	def text(ActionConstraints blockWithList){
		var what=' action contraint'
		var list = blockWithList.actionConstraints
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	
	def text(Processes blockWithList){
		var what=' process definition'
		var list = blockWithList.processDefinitions
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	def text(ProcessDiagram blockWithList){
		var what=' process'
		var whatPlural= ' processes'
		var list = blockWithList.processes
		if(list===null){write(0,what,whatPlural)} 
		else{write(list.size,what,whatPlural)}
	}
	
	def text(FatherAndSons f){
		f.father.name +' -> {'+text(f.sonsSet)+'}'
	}
	def text(XORFatherAndSons f){
		f.father.name +' -XOR> {'+text(f.sonsSet)+'}'
	}
	def text(ORFatherAndSons f){
		f.father.name +' -OR> {'+text(f.sonsSet)+'}'
	}
	def text(SetOfPossiblyOptionalFeatures s){
		var what=' feature'
		var list = s.features
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	def text(SetOfFeatures s){
		var what=' feature'
		var list = s.features
		if(list===null){write(0,what)} 
		else{write(list.size,what)}
	}
	def text(SetOfConcreteFeatures s){
		/*var what=' concrete feature'
		var list = s.features
		if(list===null){write(0,what)} 
		else{write(list.size,what)}*/
		writeSetOfConcreteFeatures(s)
	}
	
	def writeSetOfConcreteFeatures(SetOfConcreteFeatures features) {
		var sb = new StringBuilder("{ ")
		if(features!==null){
			for(f : features.features){
				sb.append(f.name)
				sb.append(' , ')
			}
		}
		sb.delete(sb.length-3,sb.length)
		sb.append(" }")
	}
	
	def text(FeatureRequires f){
		getName(f.requirer) +' requires '+getName(f.required)
	}
	def text(FeatureExcludes f){
		getName(f.first) +' excludes '+getName(f.second)
	}
	
	def text(Feature feature){
		getName(feature)
	}
	
	def text(FeaturePredicateValue fp){
		getName(fp.feature)+ ' = ' + MyParserUtil.visitExpr(fp.value)
	}
	def text(QFLanVariable v){
		v.name + ' = ' + MyParserUtil.visitExpr(v.value);
	}
	def text(Expression exp){
		MyParserUtil.visitExpr(exp)
	}
	def text(BoolExpr exp){
		//QFLanGenerator.visitConstraint(exp)
		MyParserUtil.visitConstraint(exp)
	}
	def text(ActionRequires ar){
		//MyParserUtil.visitActionRequires(ar)
		var action=MyParserUtil.visitActionIncludingStoreModifierOrFeature(ar.getAction());
		"Execution of "+action+" requires...";
	}
	
	def text(ProcessExpr p){
		//QFLanGenerator.visitProcess(p)
		MyParserUtil.visitProcess(p);
	}
	def text(InitWithProcesses is){
		'Init: '+is.initialProcess.name+' -- '+writeSetOfConcreteFeatures(is.installedFeatures);
	}
	def text(InitWithProcessDiagram is){
		var StringBuilder sb=new StringBuilder()
		for(proc:is.processes){
			sb.append(proc.name)
			sb.append(' | ')
		}
		sb.delete(sb.length-3,sb.length)
		'Init: '+sb.toString+' -- '+writeSetOfConcreteFeatures(is.installedFeatures);
	}
	def text(Simulate s){
		'Simulation of ' + s.steps + ' steps with seed ' + s.seed
	}
	def text(Analysis a){
		var q = a.queryFile
		if(q===null){
			'SMC'
		}
		else{
			'SMC of query '+q
		}
		
	}
	
	
	def getName(Feature feature) {
		if(feature instanceof AbstractFeature){
			return feature.name
		}
		else if(feature instanceof ConcreteFeature){
			return feature.name
		} 
		return ""
	}
	
	
	
	
	def write(int size, String what) {
		if(size==1){
			size +what	
		}
		else{
			size + what+'s'
		}
	}
	
	def write(int size, String what, String whatPlural) {
		if(size==1){
			size +what	
		}
		else{
			size + whatPlural
		}
	}

}

/*
 * generated by Xtext 2.13.0
 */
package it.imt.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import it.imt.qFLan.Action
import it.imt.qFLan.ModelDefinition
import java.util.Iterator
import it.imt.qFLan.AbstractFeature
import it.imt.qFLan.ConcreteFeature
import it.imt.qFLan.FatherAndSons
import it.imt.qFLan.Feature
import it.imt.qFLan.FeaturePredicate
import it.imt.qFLan.FeaturePredicateValue
import it.imt.MyParserUtil
import it.imt.qFLan.FeatureRequires
import it.imt.qFLan.HasFeature
import org.eclipse.emf.common.util.EList
import it.imt.qFLan.FalseConstraint
import it.imt.qFLan.TrueConstraint
import it.imt.qFLan.DisequationOfPredicateExpr
import it.imt.qFLan.NotConstraintExpr
import it.imt.qFLan.BoolExpr
import it.imt.qFLan.ActionRequires
import it.imt.qFLan.InstallAction
import it.imt.qFLan.UninstallAction
import it.imt.qFLan.AskAction
import it.imt.qFLan.ReplaceAction
import it.imt.qFLan.AndBoolConstraintExpr
import it.imt.qFLan.OrBoolConstraintExpr
import it.imt.qFLan.ImpliesBoolConstraintExpr
import it.imt.qFLan.ReferenceToActionOrFeature
//import it.imt.qFLan.Constraints
import it.imt.qFLan.Expression
import it.imt.qFLan.Predicate
import it.imt.qFLan.MinusPrimaryWithPredicates
import it.imt.qFLan.SubtractionWithPredicates
import it.imt.qFLan.AdditionWithPredicates
import it.imt.qFLan.Multiplication
import it.imt.qFLan.Addition
import it.imt.qFLan.MinusPrimary
import it.imt.qFLan.Subtraction
import it.imt.qFLan.NumberLiteral
import it.imt.qFLan.MultiplicationWithPredicates
import it.imt.qFLan.Processes
import it.imt.qFLan.ProcessDefinition
import it.imt.qFLan.ZeroProcess
import it.imt.qFLan.Prefix
import it.imt.qFLan.ProcessExpr
import it.imt.qFLan.ReferenceToProcessDefinition
import it.imt.qFLan.Choice
import it.imt.qFLan.Sequential
import it.imt.qFLan.Parallel
import it.imt.qFLan.QFLanVariable
import it.imt.qFLan.RefToQFLanVariable
import it.imt.qFLan.SideEffects
//import it.imt.qFLan.SideEffect
import it.imt.qFLan.SetOfConcreteFeatures
import it.imt.qFLan.ActionConstraints
//import it.imt.qFLan.FatherAndSonsRelations
import it.imt.qFLan.CrossTreeConstraints
import it.imt.qFLan.QuantitativeConstraints
import it.imt.qFLan.ORFatherAndSons
import it.imt.qFLan.XORFatherAndSons
import it.imt.qFLan.PossiblyOptionalFeature
import it.imt.qFLan.SetOfFeatures
import it.imt.qFLan.CrossTreeConstraint
import it.imt.qFLan.FeatureExcludes
import it.imt.qFLan.FatherAndSonsRelations
import java.util.ArrayList
import it.imt.qFLan.StoreModifierActionOrReferenceToActionOrToFeature
import it.imt.qFLan.StoreModifierActions
import it.imt.qFLan.AskOrStoreModifierActionOrReferenceToActionOrToFeature
import it.imt.qFLan.NonParametricQueries
import it.imt.qFLan.ParametricQuery
import it.imt.qFLan.Analysis
import it.imt.qFLan.InitWithProcesses
import it.imt.qFLan.InitWithProcessDiagram
import it.imt.qFLan.ProcessDiagram
import it.imt.qFLan.ProcessOfDiagram
import java.util.LinkedHashMap
import java.util.List
import it.imt.qFLan.ReferenceToProcessState
import it.imt.qFLan.ProcessTransition
import it.imt.qFLan.UntilQuery
import it.imt.qFLan.SteadyStateQuery
import it.imt.qFLan.ProcessState
import it.imt.qFLan.ReferenceToProcessStateOrZeroProcess
import it.imt.qFLan.Division
import it.imt.qFLan.Power
import org.eclipse.xtext.util.StringInputStream

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class QFLanGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
		
		
		var modelDefs = resource.allContents.filter(typeof(ModelDefinition))
		var modelDef = modelDefs.next
		var modelName = modelDef.name
		var qflanVariables = resource.allContents.filter(typeof(QFLanVariable))
		var abstractFeatures = resource.allContents.filter(typeof(AbstractFeature))
		var concreteFeatures = resource.allContents.filter(typeof(ConcreteFeature)).toList
		var relationsAmongFeatures = resource.allContents.filter(typeof(FatherAndSonsRelations))
		/*var normalRelationsAmongFeatures = resource.allContents.filter(typeof(FatherAndSons))
		var orrelationsAmongFeatures = resource.allContents.filter(typeof(ORFatherAndSons))
		var xorrelationsAmongFeatures = resource.allContents.filter(typeof(XORFatherAndSons))*/
		var featurePredicates = resource.allContents.filter(typeof(FeaturePredicate))
		var actions = resource.allContents.filter(typeof(Action))
		var listOfActionConstraints = resource.allContents.filter(typeof(ActionConstraints))
		var actionConstraints = listOfActionConstraints.next.actionConstraints
		var listOfCrossTreeConstraints = resource.allContents.filter(typeof(CrossTreeConstraints))
		var crossTreeConstraints = listOfCrossTreeConstraints.next.crossTreeConstraints
		var listOfQuantitativeConstraints = resource.allContents.filter(typeof(QuantitativeConstraints))
		var quantitativeConstraints = listOfQuantitativeConstraints.next.quantitativeConstraints
		var hasProcessDiagram=true;
		//var listOfprocessDefinitions = resource.allContents.filter(typeof(Processes))
		var EList<ProcessDefinition> processDefinitions = null;
		/*if(listOfprocessDefinitions!==null && listOfprocessDefinitions.size>0){
			processDefinitions = listOfprocessDefinitions.next.processDefinitions
			hasProcessDiagram=false
		} */
		var EList<ProcessOfDiagram> processesOfDiagram = null;
		var InitWithProcessDiagram initWithProcessesOfDiagram=null
		var InitWithProcesses initWithProcesses = null
		for(elem:modelDef.elements){
			if(elem instanceof ProcessDiagram){
				processesOfDiagram=elem.processes
			}
			else if(elem instanceof InitWithProcessDiagram){
				initWithProcessesOfDiagram=elem
			}
			else if(elem instanceof InitWithProcesses){
				initWithProcesses=elem
			}
			else if(elem instanceof Processes){
				processDefinitions = elem.processDefinitions
				hasProcessDiagram=false
			} 
		}
		
		var processDiagramsList = resource.allContents.filter(typeof(ProcessOfDiagram)).toList
		/*var processDiagram = resource.allContents.filter(typeof(ProcessDiagram));
		var EList<ProcessOfDiagram> processesOfDiagram = null;
		if(hasProcessDiagram && processDiagram!==null && processDiagram.size>0){
			var tmp = processDiagram.next
			processesOfDiagram=tmp.processes
		}*/
		var LinkedHashMap<String, String> nameOfProcessToNameOfFirstState=new LinkedHashMap<String, String>(); 
		//var initWithProcesses = resource.allContents.filter(typeof(InitWithProcesses))
		//var initWithProcessesOfDiagram = resource.allContents.filter(typeof(InitWithProcessDiagram))
				
				
				
		var javaEncoding =//'''package it.imt.qflan.core.models;
'''

import java.util.Arrays;

import com.microsoft.z3.Z3Exception;

import it.imt.qflan.core.features.*;
import it.imt.qflan.core.features.interfaces.*;
import it.imt.qflan.core.model.*;
import it.imt.qflan.core.predicates.*;
import it.imt.qflan.core.predicates.interfaces.*;
import it.imt.qflan.core.processes.*;
import it.imt.qflan.core.processes.interfaces.*;
import it.imt.qflan.core.processes.constraints.*;
import it.imt.qflan.core.processes.actions.*;
import it.imt.qflan.core.variables.QFLanVariable;
import it.imt.qflan.core.variables.SideEffect;
			
public class «modelName» implements IQFlanModelBuilder{
	
	public «modelName»(){
			System.out.println("Model builder instantiated");
		}
	
	public QFlanModel createModel() throws Z3Exception{
		QFlanModel model = new QFlanModel();
			
		//////////////////
		/////Variables////
		//////////////////
		«writeVariables(qflanVariables)»	
			
		//////////////////
		/////Features/////
		//////////////////
		«writeFeatures(abstractFeatures,concreteFeatures.iterator,relationsAmongFeatures)»
			
		/////////////////////////////
		////CrossTree Constraints////
		/////////////////////////////
		«writeCrossTreeConstraints(crossTreeConstraints)»	
			
		//////////////////
		////Predicates////
		//////////////////
		«writeFeaturePredicates(featurePredicates)»
		
		////////////////////////////////
		////Quantitative Constraints////
		////////////////////////////////
		«writeQuantitativeConstraints(quantitativeConstraints)»
		
		///////////////
		////Actions////
		///////////////
		«writeActions(actions)»
		
		//////////////////////////
		////Action constraints////
		//////////////////////////
		«writeActionConstraints(actionConstraints,concreteFeatures.iterator)»		
		
		/////////////////////////////
		////Processes definitions////
		/////////////////////////////
		«writeProcesses(processDefinitions)»
		«writeProcessesOfDiagram(processesOfDiagram,nameOfProcessToNameOfFirstState)»
		
		/////////////////////////////////////////////////
		////Initially installed features and Process ////
		/////////////////////////////////////////////////
		«writeInit(initWithProcesses,initWithProcessesOfDiagram,hasProcessDiagram,nameOfProcessToNameOfFirstState)»
		model.resetToInitialState();
		return model;		
	}
}
			
			
		'''
		fsa.generateFile(modelName+'.java',javaEncoding)

		//var hasParametricQuery=false;
		//var hasNonParametricQueries=false;
		//var hasUntilQuery=false;
		for(e : modelDef.elements){
			if(e instanceof Analysis){
				var query = e.query;
				if(query!==null){
					var queryString=""
					if(query instanceof NonParametricQueries){
						queryString=MyParserUtil.computeQuery(query)
						//hasParametricQuery=false;
						//hasNonParametricQueries=true;
						//hasUntilQuery=false;
					}
					else if(query instanceof ParametricQuery){
						queryString=MyParserUtil.computeQuery(query)
						//hasParametricQuery=true;
						//hasNonParametricQueries=false;
						//hasUntilQuery=false;
					}
					else if(query instanceof UntilQuery){
						queryString=MyParserUtil.computeQuery(query)
						//hasParametricQuery=false;
						//hasNonParametricQueries=false;
						//hasUntilQuery=true;
					} 
					else if(query instanceof SteadyStateQuery){
						queryString=MyParserUtil.computeQuery(query)
					}
					
				
					if(queryString!==null && !queryString.equals("")){
						fsa.generateFile('query'+modelName+'.multiquatex', queryString)
					}
				}
			}
		}
		
		//Here begins generation of .graphviz file (DOT file)
		//TODO
		//var AttackTree=...
	
	var fileName=modelName + 'ProProcess.dot';	
	var ProbProcess=
	'''
/* Open in your favourite Graphviz viewer, e.g.
 * https://dreampuf.github.io/GraphvizOnline/
 * https://edotor.net/
 */
	digraph «modelName» {
		«genStates(processDiagramsList.iterator)»
	}
	'''
	fileName=modelName + 'Attacker.dot';
	fsa.generateFile(fileName, ProbProcess)
	MyParserUtil.generateFigure(new StringInputStream(ProbProcess),modelName + 'Process',resource)
		
		/*fsa.generateFile(modelName+'.java', 
			'All defined actions: ' + 
			resource.allContents
				.filter(typeof(Action))
				.map[name]
				.join(', '))*/
	}
	
	def cleanStateName(ProcessState state){
			var name = state.name
			return cleanStateName(name)
		}
	def cleanStateName(String name){
		var cleanedName=name
		if(name.startsWith("s")){
			cleanedName = name.substring(1)
		}
		return cleanedName
	}
	
	def genStates(Iterator<ProcessOfDiagram> attackDiagrams) {
			var sb = new StringBuffer()
			while (attackDiagrams.hasNext) {
				var diagram = attackDiagrams.next
				var states = diagram.eAllContents.filter(typeof(ProcessState))
				sb.append(
				'''
				subgraph «diagram.name» {
					//States
					node [shape=box style=rounded color=blue penwidth=4.0]
				'''
				)
				while (states.hasNext) {
					var state = states.next
					sb.append("\t")
					sb.append(
					'''
					«cleanStateName(state.name)»
					''')
				}
			
				var transitions = diagram.eAllContents.filter(typeof(ProcessTransition))
				sb.append("\t")
				sb.append(
				'''
				//Transitions
					edge [color=blue penwidth=2.0]
				'''
				)
				while (transitions.hasNext) {
					//java.lang.ClassCastException: class it.imt.qFLan.impl.AskActionImpl cannot be cast to class it.imt.qFLan.StoreModifierActionOrReferenceToActionOrToFeature (it.imt.qFLan.impl.AskActionImpl and it.imt.qFLan.StoreModifierActionOrReferenceToActionOrToFeature are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @34e113d3)
					
					var transition = transitions.next
					sb.append("\t")
					sb.append(
						'''
						«cleanStateName(transition.source.name)» -> «cleanStateName(getName(transition.target))» [label="«genAction(transition.action as AskOrStoreModifierActionOrReferenceToActionOrToFeature)»,«evalExpr(transition.rate) as double»"]
						'''
					)
				}
				sb.append("}\n")			
			}

			
			return sb.toString
		}
		
		def String getName(ReferenceToProcessStateOrZeroProcess process) {
			if(process instanceof ZeroProcess){
				return "nil";
			}
			else {
				return (process as ReferenceToProcessState).value.name;
			}
		}
		
		
	def static double evalExpr(Expression expr) {
			var rightVisited = 0.0
			var leftVisited = 0.0
			if(expr instanceof NumberLiteral){
				return expr.value
			}
//			else if(expr instanceof RefToVariable){
//				//return expr.varname.name
//				return 0.0
//			}
			else if(expr instanceof Predicate){
				//return expr.predicate.name
				return 0.0
			}
			else if(expr instanceof Addition || expr instanceof AdditionWithPredicates){
				if(expr instanceof Addition){
					leftVisited = evalExpr(expr.left)
					rightVisited = evalExpr(expr.right)
				}
				else if(expr instanceof AdditionWithPredicates){
					leftVisited = evalExpr(expr.left)
					rightVisited = evalExpr(expr.right)
				}
				//return '''«leftVisited» + «rightVisited»'''
				return leftVisited + rightVisited
			}
			else if(expr instanceof Subtraction || expr instanceof SubtractionWithPredicates){
				if(expr instanceof Subtraction){
					leftVisited = evalExpr(expr.left)
					rightVisited = evalExpr(expr.right)
				}
				else if(expr instanceof SubtractionWithPredicates){
					leftVisited = evalExpr(expr.left)
					rightVisited = evalExpr(expr.right)
				}
				//return '''«leftVisited» - «rightVisited»'''
				return leftVisited - rightVisited
			}
			else if(expr instanceof Multiplication || expr instanceof MultiplicationWithPredicates){
				if(expr instanceof Multiplication){
					leftVisited = evalExpr(expr.left)
					rightVisited = evalExpr(expr.right)
				}
				else if(expr instanceof MultiplicationWithPredicates){
					leftVisited = evalExpr(expr.left)
					rightVisited = evalExpr(expr.right)
				}
				//return '''«leftVisited» * «rightVisited»'''
				return leftVisited * rightVisited
			}
			else if (expr instanceof Division) {
				leftVisited = evalExpr(expr.left)
				rightVisited = evalExpr(expr.right)
				return leftVisited / rightVisited
			}
			else if (expr instanceof Power) {
				leftVisited = evalExpr(expr.left)
				rightVisited = evalExpr(expr.right)
				return leftVisited ** rightVisited
			}
			else if(expr instanceof MinusPrimary || expr instanceof MinusPrimaryWithPredicates){
				if(expr instanceof MinusPrimary){
					leftVisited = evalExpr(expr.left)
				}
				else if(expr instanceof MinusPrimaryWithPredicates){
					leftVisited = evalExpr(expr.left)
				}
				//return '''-«leftVisited»'''
				return -leftVisited
			}
			else{
				throw new UnsupportedOperationException("Unsupported expression: " + expr.toString());
			}
	}
		
	def static genAction(AskOrStoreModifierActionOrReferenceToActionOrToFeature action) {
			if(action instanceof Action){
				return cleanActionName(action.name)
			}
			else if(action instanceof ReferenceToActionOrFeature){
				var referencedActionOrFeautre = action.value
				if(referencedActionOrFeautre instanceof Action){
					return cleanActionName(referencedActionOrFeautre.name)
				}
				else if(referencedActionOrFeautre instanceof ConcreteFeature){
					return referencedActionOrFeautre.name
				}
				else if(referencedActionOrFeautre instanceof AbstractFeature){
					return referencedActionOrFeautre.name
				}
			}
			else if(action instanceof StoreModifierActions){
				if(action instanceof InstallAction){
					return '''install(«action.feature.name»)'''
				}
				else if(action instanceof UninstallAction){
					return '''uninstall(«action.feature.name»)'''
				}
				else if(action instanceof ReplaceAction){
					return '''replace(«action.toRemove.name»,«action.toAdd.name»)'''
				}
				else{
					throw new UnsupportedOperationException("Unsupported action: " + action);
				}
			}
			else if(action instanceof AskAction){
				return '''ask(«visitConstraint(action.question)»)'''
			}
		}
	
	def static cleanActionName(String name){
		var cleanedName = name
		if(name.equalsIgnoreCase("tryAction") || name.equalsIgnoreCase("tryAct")){
			cleanedName = "try"
		}
		return cleanedName
	}
	
	def writeInit(InitWithProcesses processes, InitWithProcessDiagram diagram, boolean hasProcessDiagram,LinkedHashMap<String, String> nameOfProcessToNameOfFirstState) {
		var ret="";
		if(hasProcessDiagram){
			if(diagram!==null){
				if(diagram.processes.size()==1){
					ret='''model.setInitialState(«listOfFeatures(diagram.installedFeatures)», «nameOfProcessToNameOfFirstState.get(diagram.processes.get(0).name)»);'''
				}
				else{
					ret=
'''
ProcessDefinition initial= new ProcessDefinition("init");
model.addProcessDefinition(initial, QFlanModel.makeMultiParallel(«listOfInitialProcesses(diagram.processes,nameOfProcessToNameOfFirstState)»));
model.setInitialState(«listOfFeatures(diagram.installedFeatures)», initial);
'''
				}
			}
		}
		else{
			if(processes!==null){
				var initialState=processes
				ret='''model.setInitialState(«listOfFeatures(initialState.installedFeatures)», «initialState.initialProcess.name»);'''	
			}
		}
		return ret
	}
	
	def static listOfInitialProcesses(EList<ProcessOfDiagram> processes,LinkedHashMap<String, String> nameOfProcessToNameOfFirstState){
		var sb = new StringBuilder("Arrays.asList(");
		if(processes!==null){
			for(ProcessOfDiagram process : processes){
				sb.append('(IProcess)')
				sb.append(nameOfProcessToNameOfFirstState.get(process.name))
				sb.append((','))
			}
			sb.delete(sb.length-1,sb.length);
		}
		sb.append(')')
		return sb.toString;
	}

	def writeProcesses(EList<ProcessDefinition> processDefinitions) {
		//process factory = ( factoryInstallFeatures + ( sell , 8 ) . deposit)
		if(processDefinitions!==null && processDefinitions.size>0){
			var sbProcessDefs = new StringBuffer();
			var sbProcessBodies = new StringBuffer();
			for(element : processDefinitions){
				if(element.name!==null){
					sbProcessDefs.append('''ProcessDefinition «element.name» = new ProcessDefinition("«element.name»");''')
					sbProcessDefs.append("\n")
					sbProcessBodies.append('''model.addProcessDefinition(«element.name», «visitProcess(element.body)»);''')
					sbProcessBodies.append("\n")	
				}
			}
			return sbProcessDefs.toString + "\n" + sbProcessBodies	
		}
		return "\n"
	}
	
	def writeProcessesOfDiagram(EList<ProcessOfDiagram> processesOfDiagram,LinkedHashMap<String, String> nameOfProcessToNameOfFirstState) {
		if(processesOfDiagram!==null && processesOfDiagram.size>0){
			var sbProcessDefs = new StringBuffer();
			var sbProcessBodies = new StringBuffer();
			var LinkedHashMap<String, List<String>> stateToOutgoingTransitions = new LinkedHashMap<String, List<String>>();
			for(process:processesOfDiagram){
				var List<String> allStates=new ArrayList<String>();
				var first=true;
				for(state:process.states.states){
					if(first){
						nameOfProcessToNameOfFirstState.put(process.name,state.name)
						first=false;
					}
					allStates.add(state.name)
					sbProcessDefs.append('''ProcessDefinition «state.name» = new ProcessDefinition("«state.name»");''')
					sbProcessDefs.append("\n")
				}
				for(transition:process.transitions.transitions){
					var rate=MyParserUtil.visitExpr(transition.rate);
					var action=writeActionIncludingAskOrStoreModifierOrFeature(transition.action);
					var sideEffects=visitListOfSideEffects(transition.sideEffects);
					var target=computeTarget(transition)
					var prefix='''(IProcess)new Prefix(«rate»,«action»,«sideEffects»,«target»)'''
					var outgoing=stateToOutgoingTransitions.get(transition.source.name)
					if(outgoing===null){
						outgoing=new ArrayList<String>();
						stateToOutgoingTransitions.put(transition.source.name,outgoing)
					}
					outgoing.add(prefix)
				}
				for(state : allStates){
					var out = stateToOutgoingTransitions.get(state)
					if(out===null){
						sbProcessBodies.append('''model.addProcessDefinition(«state», ZeroProcess.ZERO);''')
						sbProcessBodies.append("\n")
					}
					else{
						var str = out.toString
						str=str.substring(1,str.length-1)
						sbProcessBodies.append('''model.addProcessDefinition(«state», QFlanModel.makeMultiChoice(Arrays.asList(«str»)));''')
						sbProcessBodies.append("\n")	
					}
				}
			}
			return sbProcessDefs.toString + "\n" + sbProcessBodies
		}
		return "\n"
	}
	
	
	def static computeTarget(ProcessTransition transition){
		var target="ZeroProcess.ZERO"
		var tt=transition.target
		if(!(tt instanceof ZeroProcess)){
			var tt2 = tt as ReferenceToProcessState
			target = tt2.value.name
		}
		return target
	}
	
	def static String visitProcess(ProcessExpr process) {
	//def visitProcess(ProcessExpr process) {
		//choice, parallel, sequential, prefix, ZeroProcess, ReferenceToProcessDefinition
		if(process instanceof ZeroProcess){
			return '''ZeroProcess.ZERO'''
		}
		else if(process instanceof Prefix){
			return '''new Prefix(«MyParserUtil.visitExpr(process.rate)», «writeActionIncludingAskOrStoreModifierOrFeature(process.action)», «visitListOfSideEffects(process.sideEffects)», «visitProcess(process.continuation)»)'''
		}
		else if(process instanceof ReferenceToProcessDefinition){
			return '''«process.value.name»'''
		}
		else if(process instanceof Choice){
			return '''new Choice(«visitProcess(process.first)», «visitProcess(process.second)»)'''
		}
		else if(process instanceof Sequential){
			return '''new Sequential(«visitProcess(process.first)», «visitProcess(process.second)»)'''
		}
		else if(process instanceof Parallel){
			return '''new Parallel(«visitProcess(process.first)», «visitProcess(process.second)»)'''
		}
		else if(process instanceof ProcessExpr){
			return visitProcess(process.first)
		}
		throw new UnsupportedOperationException("Unsupported process: " + process.toString());
		
	}
	
	def static visitListOfSideEffects(SideEffects effects) {
		var sb = new StringBuilder();
		sb.append("new SideEffect[]{");
		
		if(effects!==null){
			var listOfEffects = effects.effects;
			var size = listOfEffects.size;
			var i=0;
			if(listOfEffects!==null){
				for(eff : listOfEffects){
					var name = eff.refToQFLanVar.getVarqflan.name
					var expr = eff.value;
					sb.append('''new SideEffect(«name»,«writeExpr(expr)»)''')
					if(i<size-1){
						sb.append(",");
					}
					i++;
				}
			}
		}
		sb.append("}");
		return sb.toString;
	}
	
	/*def visitListOfSideEffects(SideEffects effects) {
		var sb = new StringBuilder();
		sb.append("new String[]{");
		for(element : effects.effects){
			element.
			sb.append('''new SideEffect(«element.getVariable()»,«visitExpr(element.value)»)''')
		}
		sb.append("}");
		return sb.toString;
	}*/
	
	def writeActionConstraints(EList<ActionRequires> actionConstraints, Iterator<ConcreteFeature> concreteFeatures) {
		var sb = new StringBuffer();
		for(element : actionConstraints){
			sb.append('''model.addActionConstraint(«visitActionRequires(element)»);''')
			sb.append("\n")
		}
		
		sb.append("\n")
		sb.append("//In order to use a feature, it must be installed. These constraints are already built-in\n")
	
		while(concreteFeatures.hasNext){
			var element = concreteFeatures.next
			sb.append('''//( do(«element.name») -> has(«element.name»))''')
			sb.append("\n")
		}
		return sb.toString();
	}
	
	def writeCrossTreeConstraints(EList<CrossTreeConstraint> constraints){
		var sb = new StringBuffer();
		for(element : constraints){
			sb.append('''model.addConstraint(«visitCrossTreeConstraint(element)»);''')	
			sb.append("\n")
		}
		sb.append("\n")
		return sb.toString();
	}
	def writeQuantitativeConstraints(EList<BoolExpr> constraints/* , Iterator<ConcreteFeature> concreteFeatures*/) {
		var sb = new StringBuffer();
		for(element : constraints){
			sb.append('''model.addConstraint(«visitConstraint(element)»);''')
			sb.append("\n")
		}
		
		sb.append("\n")
		/*sb.append("//In order to use a feature, it must be installed. These constraints are already built-in\n")
	
		while(concreteFeatures.hasNext){
			var element = concreteFeatures.next
			sb.append('''//( do(«element.name») -> has(«element.name»))''')
			sb.append("\n")
		}*/
		return sb.toString();
	}
	
	/*def writeConstraints(Iterator<BoolExpr> constraints) {
		var sb = new StringBuffer();
		while(constraints.hasNext){
			var element = constraints.next
			sb.append('''model.addConstraint(«visitConstraint(element)»);''')
			sb.append("\n")
		}
		return sb.toString();
	}*/
		
	//def listOfFeatures(EList<ConcreteFeature> features){
	def listOfFeatures(SetOfConcreteFeatures featuresSet){
		var sb = new StringBuilder("Arrays.asList(");
		if(featuresSet!==null){
			var features = featuresSet.features;
			for(ConcreteFeature feature : features){
				sb.append(feature.name)
				sb.append((','))
			}
			sb.delete(sb.length-1,sb.length);
		}
		sb.append(')')
		return sb.toString;
	}
	
	def listOfFeatures(SetOfFeatures featuresSet){
		var sb = new StringBuilder("Arrays.asList(");
		if(featuresSet!==null){
			var features = featuresSet.features;
			for(Feature feature : features){
				sb.append("(IFeature)")
				if(feature instanceof AbstractFeature){
					sb.append(feature.name)	
				}
				else if(feature instanceof ConcreteFeature){
					sb.append(feature.name)
				}
				sb.append((','))
			}
			sb.delete(sb.length-1,sb.length);
		}
		sb.append(')')
		return sb.toString;
	}
		
	def static visitActionRequires(ActionRequires constraint) {
		//'do' '(' action=SpecialActionOrReferenceToActionOrToFeature ')' '->' constraint=PrimaryBooleanConstraintExpr {ActionRequires.constraint=current}
			//new ActionRequiresConstraint(sell, new DisequationOfPredicateExpressions(priceOfBike, new Constant(250), PredicateExprComparator.GE))
			var writtenAction = writeActionIncludingStoreModifierOrFeature(constraint.action)
			var writtenConstraint = visitConstraint(constraint.constraint)
			return '''new ActionRequiresConstraint(«writtenAction», «writtenConstraint»)'''
	}	
		
	def static getFeatureName(Feature feature){
		if(feature instanceof AbstractFeature){
			return feature.name;
		}
		else if(feature instanceof ConcreteFeature){
			return feature.name;
		} 
	}	
		
	def visitCrossTreeConstraint(CrossTreeConstraint constraint) {
		if(constraint instanceof FeatureRequires){
			return '''new FeatureRequireConstraint(«getFeatureName(constraint.requirer)», «getFeatureName(constraint.required)»,model)'''
		}
		else if(constraint instanceof FeatureExcludes){
			var features='''Arrays.asList((IFeature)«getFeatureName(constraint.first)»,(IFeature)«getFeatureName(constraint.second)»)''';
		    return '''new FeatureSetConstraint(«features», FeatureSetCondition.ATMOSTONE,model)''';
			//return '''new FeatureExcludesConstraint(«getFeatureName(constraint.first)», «getFeatureName(constraint.second)»,model)'''
		} 
	}	
		
	def static String visitConstraint(BoolExpr constraint) {
		/*if(constraint instanceof FeatureRequires){
			return '''new FeatureRequireConstraint(«constraint.requirer.name», «constraint.required.name»,model)'''
		}*/
		/*else if(constraint instanceof ActionRequires){
			//'do' '(' action=SpecialActionOrReferenceToActionOrToFeature ')' '->' constraint=PrimaryBooleanConstraintExpr {ActionRequires.constraint=current}
			//new ActionRequiresConstraint(sell, new DisequationOfPredicateExpressions(priceOfBike, new Constant(250), PredicateExprComparator.GE))
			var writtenAction = writeActionIncludingSpecialOrFeature(constraint.action)
			var writtenConstraint = visitConstraint(constraint.constraint)
			return '''new ActionRequiresConstraint(«writtenAction», «writtenConstraint»)'''
		}*/
		if(constraint instanceof HasFeature){
			return '''new HasFeature(«getFeatureName(constraint.feature)»,model)'''
		}
		else if(constraint instanceof FalseConstraint){
			return '''new FalseConstraint()'''
		}
		else if(constraint instanceof TrueConstraint){
			return '''new TrueConstraint()'''
		}
		else if(constraint instanceof NotConstraintExpr){
			return '''new NotConstraintExpr(«visitConstraint(constraint.left)»)'''
		}
		else if(constraint instanceof AndBoolConstraintExpr){
			return '''new BooleanConstraintExpr(«visitConstraint(constraint.left)»,«visitConstraint(constraint.right)»,BooleanConnector.AND)'''
		}
		else if(constraint instanceof OrBoolConstraintExpr){
			return '''new BooleanConstraintExpr(«visitConstraint(constraint.left)»,«visitConstraint(constraint.right)»,BooleanConnector.OR)'''
		}
		else if(constraint instanceof ImpliesBoolConstraintExpr){
			return '''new BooleanConstraintExpr(«visitConstraint(constraint.left)»,«visitConstraint(constraint.right)»,BooleanConnector.IMPLIES)'''
		}
		/*else if(constraint instanceof AtLeastOne){
			//IConstraint atLeastOneWheel2 = new FeatureSetConstraint(Arrays.asList(allYear, summer, winter), FeatureSetCondition.ATLEASTONE,model);
			var sb = new StringBuilder("new FeatureSetConstraint(");
			sb.append(listOfFeatures(constraint.featuresSet))
			return sb.toString+ ", FeatureSetCondition.ATLEASTONE,model)";
		}
		else if(constraint instanceof AtMostOne){
			//IConstraint atLeastOneWheel2 = new FeatureSetConstraint(Arrays.asList(allYear, summer, winter), FeatureSetCondition.ATLEASTONE,model);
			var sb = new StringBuilder("new FeatureSetConstraint(");
			sb.append(listOfFeatures(constraint.featuresSet))
			return sb.toString+ ", FeatureSetCondition.ATMOSTONE,model)";
		}
		else if(constraint instanceof PreciselyOne){
			var features = ""
			if(constraint.featuresSet==null){
				var name=""
				if(constraint.feature!==null){
					name=constraint.feature.name
				}
				features="Arrays.asList("+name+")";	
			}
			else{
				features = listOfFeatures(constraint.featuresSet)	
			}
			return '''new BooleanConstraintExpr(new FeatureSetConstraint(«features», FeatureSetCondition.ATLEASTONE,model),new FeatureSetConstraint(«features», FeatureSetCondition.ATMOSTONE,model),BooleanConnector.AND)''';
		}*/
		else if(constraint instanceof DisequationOfPredicateExpr){
			//new DisequationOfPredicateExpressions(priceOfBike, new Constant(250), PredicateExprComparator.GE)
			var writtenlhs = writeExpr(constraint.lhs)
			var writtenrhs = writeExpr(constraint.rhs)
			return '''new DisequationOfPredicateExpressions(«writtenlhs»,«writtenrhs»,«writeComparator(constraint.comp)»)''';
		}
		/*else{
			throw new UnsupportedOperationException("Unsupported constraint: " + constraint);
		}*/
		return ""
	}
	
	def static String writeExpr(Expression expr) {
		var rightVisited = ""
		var leftVisited = ""
		if(expr instanceof NumberLiteral){
			return '''new Constant(«expr.value»)'''
		}
		else if(expr instanceof RefToQFLanVariable){
			return '''«expr.varqflan.name»'''
		}
		else if(expr instanceof Predicate){
			var f = expr.feature
			var fName="";
			if(f instanceof AbstractFeature){
				fName=f.name;
			}
			else if(f instanceof ConcreteFeature){
				fName=f.name;
			} 
			return '''new Predicate(«expr.predicate.name», «fName»)'''
		}
		else if(expr instanceof Addition || expr instanceof AdditionWithPredicates){
			if(expr instanceof Addition){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			else if(expr instanceof AdditionWithPredicates){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			return '''new ArithmeticPredicateExpr(«leftVisited»,«rightVisited»,ArithmeticOperation.SUM)'''
		}
		else if(expr instanceof Subtraction || expr instanceof SubtractionWithPredicates){
			if(expr instanceof Subtraction){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			else if(expr instanceof SubtractionWithPredicates){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			return '''new ArithmeticPredicateExpr(«leftVisited»,«rightVisited»,ArithmeticOperation.SUB)'''
		}
		else if(expr instanceof Multiplication || expr instanceof MultiplicationWithPredicates){
			if(expr instanceof Multiplication){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			else if(expr instanceof MultiplicationWithPredicates){
				leftVisited = writeExpr(expr.left) as String
				rightVisited = writeExpr(expr.right)  as String
			}
			return '''new ArithmeticPredicateExpr(«leftVisited»,«rightVisited»,ArithmeticOperation.MULT)'''
		}
		else if(expr instanceof MinusPrimary || expr instanceof MinusPrimaryWithPredicates){
			if(expr instanceof MinusPrimary){
				leftVisited = writeExpr(expr.left) as String
			}
			else if(expr instanceof MinusPrimaryWithPredicates){
				leftVisited = writeExpr(expr.left) as String
			}
			return '''new ArithmeticPredicateExpr(new Constant(0),«leftVisited»,ArithmeticOperation.SUB)'''
		}
		else{
			throw new UnsupportedOperationException("Unsupported expression: " + expr.toString());
		}
	}
	
	def static writeActionIncludingAskOrStoreModifierOrFeature(AskOrStoreModifierActionOrReferenceToActionOrToFeature action) {
		if(action instanceof StoreModifierActionOrReferenceToActionOrToFeature){
			return writeActionIncludingStoreModifierOrFeature(action)
		}
		else if(action instanceof AskAction){
				return '''new AskAction(«visitConstraint(action.question)»)'''
		}
		else{
			throw new UnsupportedOperationException("Unsupported action: " + action);
		} 
	}
	
	def static writeActionIncludingStoreModifierOrFeature(StoreModifierActionOrReferenceToActionOrToFeature action) {
		if(action instanceof Action){
			return action.name
		}
		else if(action instanceof ConcreteFeature){
			return action.name
		}
		else if(action instanceof ReferenceToActionOrFeature){
			var referencedActionOrFeautre = action.value
			if(referencedActionOrFeautre instanceof Action){
				return referencedActionOrFeautre.name
			}
			else if(referencedActionOrFeautre instanceof ConcreteFeature){
				return referencedActionOrFeautre.name
			} 
			else if(referencedActionOrFeautre instanceof AbstractFeature){
				return referencedActionOrFeautre.name
			} 
		}
		else if(action instanceof StoreModifierActions){
			/*new InstallAction(gps, true) new InstallAction(gps, false) 
			new AskAction(constraint) 
			new ReplaceAction(ConcreteFeature toRemove, ConcreteFeature toAdd)*/
			if(action instanceof InstallAction){
				return '''new InstallAction(«action.feature.name»,true)'''
			}
			else if(action instanceof UninstallAction){
				return '''new InstallAction(«action.feature.name»,false)'''
			}
			else if(action instanceof ReplaceAction){
				return '''new ReplaceAction(«action.toRemove.name»,«action.toAdd.name»)'''
			}
			/*else if(action instanceof AskAction){
				return '''new AskAction(«visitConstraint(action.question)»)'''
			}*/
			else{
				throw new UnsupportedOperationException("Unsupported action: " + action);
			}
		}
	}
	
	def static writeComparator(String comp) {
		if(comp.equals(">")){
			return "PredicateExprComparator.GE"
		}
		else if(comp.equals("<")){
			return "PredicateExprComparator.LE"
		}
		else if(comp.equals(">=")){
			return "PredicateExprComparator.GEQ"
		}
		else if(comp.equals("<=")){
			return "PredicateExprComparator.LEQ"
		}
		else if(comp.equals("==")){
			return "PredicateExprComparator.EQ"
		} 
		else if(comp.equals("!=")){
			return "PredicateExprComparator.NOTEQ"
		}
		else{
			throw new UnsupportedOperationException("Unsupported comparator: " + comp);
		}
	}
	
	def writeFeaturePredicates(Iterator<FeaturePredicate> predicates) {
		/*IPredicateDef price = new PredicateDef("price");
		  model.addPredicateDef(price);
		  */
		var sb = new StringBuffer();
		
		while(predicates.hasNext){
			var element = predicates.next
			var predicateName =element.name
			sb.append('''
IPredicateDef «predicateName» = new PredicateDef("«predicateName»");
model.addPredicateDef(«predicateName»);
''')
			for(FeaturePredicateValue featureAndValue : element.values){
				//Here I need matheval 
				sb.append('''«predicateName».setValue(«featureAndValue.feature.name»,«MyParserUtil.visitExpr(featureAndValue.value)»);''')
				sb.append("\n")
			}
			sb.append("\n")
		}
		
		return sb.toString();
	}
	
	def writeFeatures(Iterator<AbstractFeature> abstractFeatures, Iterator<ConcreteFeature> concreteFeatures,Iterator<FatherAndSonsRelations> relationsAmongFeatures) {
		var sb = new StringBuffer();
		var hierachicalConstraints = new ArrayList<String>();
		
		sb.append('//ABSTRACT FEATURES\n')
		while(abstractFeatures.hasNext){
			var element = abstractFeatures.next
			sb.append(
'''
AbstractFeature «element.name» = new AbstractFeature("«element.name»");
model.addAbstractFeatureDefinition(«element.name»);
'''
)
		}
		
		sb.append("\n")
		sb.append('//CONCRETE FEATURES\n')
		while(concreteFeatures.hasNext){
			var element = concreteFeatures.next
			sb.append(
'''
ConcreteFeature «element.name» = new ConcreteFeature("«element.name»");
model.addConcreteFeatureDefinition(«element.name»);
'''
)
		}
		
		sb.append("\n")
		sb.append('//DIAGRAM\n')
		
		while(relationsAmongFeatures.hasNext){
			var relation = relationsAmongFeatures.next
			if(relation instanceof FatherAndSons){
				sb.append('//Normal relation\n')
				writeNormalRelationAmongFeatures(relation,sb,hierachicalConstraints)
			} else if(relation instanceof ORFatherAndSons){
				sb.append('//OR relation\n')
				writeORRelationAmongFeatures(relation,sb,hierachicalConstraints)
			} else if(relation instanceof XORFatherAndSons){
				sb.append('//XOR relation\n')
				writeXORRelationAmongFeatures(relation,sb,hierachicalConstraints)
			} 
		}
		sb.append('model.computeDescendantsAndAncestors();\n');
		
		sb.append('\n////////////////////////////\n')
		sb.append('//Hierarchical constraints//\n')
		sb.append('////////////////////////////\n')
		for(hierConstr : hierachicalConstraints){
			sb.append(hierConstr);
			sb.append('\n');
		}
		return sb.toString;
	}
	
	def writeNormalRelationAmongFeatures(FatherAndSons relation,StringBuffer sb,ArrayList<String> hierarchicalConstraints){
		var father =relation.father.name
		for(PossiblyOptionalFeature possiblyson : relation.sonsSet.features){
			var son=possiblyson.mandatoryFeature
			var mandatory=true
			if(son===null){
				son=possiblyson.optionalFeature
				mandatory=false
			}
			var sonName = ""
			if(son instanceof AbstractFeature){
				sonName = son.name
			}
			else if(son instanceof ConcreteFeature){
				sonName = son.name
			}
			sb.append('''«father».addSon(«sonName»);''')
			sb.append("\n")
			if(mandatory){
				sb.append('''«sonName».setOptional(false);''')
				sb.append("\n")
				hierarchicalConstraints.add('''model.addConstraint(new HasFeature(«sonName»,model,true));''');
			}
		}
		sb.append("\n")
	}
	
	def writeORRelationAmongFeatures(ORFatherAndSons relation,StringBuffer sb,ArrayList<String> hierarchicalConstraints){
		var father =relation.father.name
		for(Feature son : relation.sonsSet.features){
			var sonName = getFeatureName(son)
			sb.append('''«father».addSon(«sonName»);''')
			sb.append("\n")
		}
		sb.append("\n")
		var features=listOfFeatures(relation.sonsSet)
		hierarchicalConstraints.add('''model.addConstraint(new Alternative_OrConstraint(«father»,«features», Alternative_ORCondition.OR,model));''');
	}
	
	def writeXORRelationAmongFeatures(XORFatherAndSons relation,StringBuffer sb,ArrayList<String> hierarchicalConstraints){
		var father =relation.father.name
		for(Feature son : relation.sonsSet.features){
			var sonName = getFeatureName(son)
			sb.append('''«father».addSon(«sonName»);''')
			sb.append("\n")
		}
		sb.append("\n")
		var features=listOfFeatures(relation.sonsSet)
		hierarchicalConstraints.add('''model.addConstraint(new Alternative_OrConstraint(«father»,«features», Alternative_ORCondition.XOR,model));''');
	}
	
	/*
	def writeFeatures(Iterator<AbstractFeature> abstractFeatures, Iterator<ConcreteFeature> concreteFeatures,Iterator<FatherAndSons> normalrelationsAmongFeatures,Iterator<ORFatherAndSons> orrelationsAmongFeatures,Iterator<XORFatherAndSons> xorrelationsAmongFeatures) {
		var sb = new StringBuffer();
		
		//ABSTRACT FEATURES
		while(abstractFeatures.hasNext){
			var element = abstractFeatures.next
			sb.append(
'''
AbstractFeature «element.name» = new AbstractFeature("«element.name»");
model.addAbstractFeatureDefinition(«element.name»);
'''
)
		}
		
		sb.append("\n")
		//CONCRETE FEATURES
		while(concreteFeatures.hasNext){
			var element = concreteFeatures.next
			sb.append(
'''
ConcreteFeature «element.name» = new ConcreteFeature("«element.name»");
model.addConcreteFeatureDefinition(«element.name»);
'''
)
		}


		sb.append("\n")
		//DIAGRAM
		while(normalrelationsAmongFeatures.hasNext){
			var relation = normalrelationsAmongFeatures.next
			var father =relation.father.name
			for(PossiblyOptionalFeature possiblyson : relation.sonsSet.features){
				var son=possiblyson.mandatoryFeature
				var mandatory=true
				if(son==null){
					son=possiblyson.optionalFeature
					mandatory=false
				}
				var sonName = ""
				if(son instanceof AbstractFeature){
					sonName = son.name
				}
				else if(son instanceof ConcreteFeature){
					sonName = son.name
				}
				sb.append('''«father».addSon(«sonName»);''')
				sb.append("\n")
				if(mandatory){
					sb.append('''model.addConstraint(new HasFeature(«sonName»,model));''')
					sb.append("\n")
				}
			}
			sb.append("\n")
		}
		while(orrelationsAmongFeatures.hasNext){
			var relation = orrelationsAmongFeatures.next
			var father =relation.father.name
			for(Feature son : relation.sonsSet.features){
				var sonName = ""
				if(son instanceof AbstractFeature){
					sonName = son.name
				}
				else if(son instanceof ConcreteFeature){
					sonName = son.name
				}
				sb.append('''«father».addSon(«sonName»);''')
				sb.append("\n")
			}
			var features=listOfFeatures(relation.sonsSet)
			sb.append('''model.addConstraint(new FeatureSetConstraint(«features», FeatureSetCondition.ATLEASTONE,model));''');
			sb.append("\n")
			sb.append("\n")
		}
		while(xorrelationsAmongFeatures.hasNext){
			var relation = xorrelationsAmongFeatures.next
			var father =relation.father.name
			for(Feature son : relation.sonsSet.features){
				var sonName = ""
				if(son instanceof AbstractFeature){
					sonName = son.name
				}
				else if(son instanceof ConcreteFeature){
					sonName = son.name
				}
				sb.append('''«father».addSon(«sonName»);''')
				sb.append("\n")
			}
			var features=listOfFeatures(relation.sonsSet)
			sb.append('''model.addConstraint(new BooleanConstraintExpr(new FeatureSetConstraint(«features», FeatureSetCondition.ATLEASTONE,model),new FeatureSetConstraint(«features», FeatureSetCondition.ATMOSTONE,model),BooleanConnector.AND));\n''');
			sb.append("\n")
		}
		
		return sb.toString();
	}*/

	
	def writeActions(Iterator<Action> actions) {
		var sb = new StringBuffer();
		while(actions.hasNext){
			var action = actions.next
			sb.append(
'''
NormalAction «action.name» = new NormalAction("«action.name»");
model.addNormalAction(«action.name»);
'''
)
		}
		return sb.toString();
	}	
	
	
	def writeVariables(Iterator<QFLanVariable> variables) {
		var sb = new StringBuffer();
		while(variables.hasNext){
			var variable = variables.next
			sb.append(
/*'''
QFLanVariable «variable.name» = model.addVariable("«variable.name»", "«MyParserUtil.visitExpr(variable.value)»");
'''*/
'''
QFLanVariable «variable.name» = model.addVariable("«variable.name»", «writeExpr(variable.value)»);
'''
)
		}
		return sb.toString();
	}	
		
}
